关于MIT6.S081这堂课上，我们可以通过一个叫做XV6的操作系统，通过动手操作，对操作系统有更深刻的理解。通过研究现有的操作系统，并结合教学配套的实验，我们可以对操作系统进行扩展，修改并提升操作系统的一些经验，并且可以通过操作系统接口，编写系统软件。
麻省理工操作系统课程 2020 课程表： https://pdos.csail.mit.edu/6.828/2020/schedule.html
1.1 操作系统的共性
通常来说，操作系统有它们共同的特性，如：
1、抽象硬件（Abstraction）
在操作系统中，抽象硬件是指将底层硬件资源抽象成高级的软件接口，使得应用程序开发者能够更加方便地使用底层硬件资源。通过抽象硬件，应用程序可以使用简单而易于理解的接口来访问硬件资源，而不需要了解底层硬件的细节。
操作系统中的抽象硬件可以分为以下几种类型：
文件系统（File System）：文件系统是将底层存储设备抽象成了一个文件和目录的层次结构。应用程序可以使用文件系统接口来读写文件，而不需要了解底层存储设备的细节。
网络接口（Network Interface）：网络接口是将底层网络设备（如网卡）抽象成了一个网络接口，应用程序可以通过网络接口来发送和接收网络数据包，而不需要了解底层网络设备的细节。
内存管理（Memory Management）：内存管理是将底层物理内存抽象成了一个虚拟内存空间。应用程序可以使用内存管理接口来申请和释放虚拟内存，而不需要了解底层物理内存的细节。
进程管理（Process Management）：进程管理是将底层CPU抽象成了一个进程调度器，应用程序可以使用进程管理接口来创建和管理进程，而不需要了解底层CPU的细节。
通过抽象硬件，操作系统提供了一系列高级的软件接口，使得应用程序开发者可以更加方便地使用底层硬件资源。这样，应用程序可以更加专注于业务逻辑的开发，而不需要了解底层硬件的细节，从而提高了开发效率和软件质量。
2、Multiplex（多路复用）
在计算机科学中，Multiplexing（多路复用）是指多个独立的数据流在同一通信信道上进行传输的过程。在操作系统中，Multiplexing通常是指通过某种机制，将多个进程或任务在同一CPU上轮流执行，以实现CPU的高效利用。即多个应用程序之间可以共用硬件资源。如：在一个操作系统同时运行文本编辑器，程序编译器，多个数据库等等。操作系统能非常神奇的在不相互干扰的前提下，同时运行这些程序。这里通常被称为multiplex。
Multiplexing技术在操作系统中的应用非常广泛，可以有效提高系统的并发处理能力和资源利用率。
操作系统中的Multiplexing技术可以分为以下几种类型：
时间分片（Time Slicing）：操作系统会将CPU的执行时间划分为多个时间片，每个时间片用于执行一个进程。当一个时间片结束时，操作系统会将CPU分配给下一个进程，并将当前进程的状态保存到内存中。
空间复用（Space Sharing）：多个进程可以共享同一块内存，从而避免了为每个进程分配独立的内存空间的开销。在空间复用的过程中，操作系统会为每个进程分配独立的地址空间，以保证它们之间不会相互干扰。
信号复用（Signal Multiplexing）：操作系统中的信号复用是指多个进程可以共享同一套信号处理函数。当一个信号被触发时，操作系统会将信号发送给所有注册了该信号处理函数的进程。
输入/输出复用（I/O Multiplexing）：在I/O复用的过程中，多个进程可以共享同一输入/输出设备。当一个进程正在使用设备时，其他进程需要等待该进程释放设备后才能访问。
3、隔离性（Isolation）
在操作系统中，隔离性（Isolation）是指通过软件和硬件机制将不同的计算机资源隔离开来，使得它们在使用时不会相互影响。隔离性是保证操作系统稳定性和安全性的重要手段之一。
操作系统中的隔离性可以分为以下几种类型：
进程隔离：操作系统中的进程是被隔离的基本单位，不同进程之间的内存、文件、网络等资源是相互独立的。进程之间不能直接访问对方的内存空间，只能通过操作系统提供的进程间通信机制进行通信。
用户隔离：在多用户系统中，操作系统可以将不同的用户隔离开来，每个用户只能访问自己的文件、进程和网络资源，而不能访问其他用户的资源。这种隔离性可以防止恶意用户对系统造成破坏。
虚拟化隔离：虚拟化技术可以将一台物理机器虚拟出多台逻辑机器，每台逻辑机器之间是相互隔离的，它们拥有独立的操作系统、内存和硬件资源。虚拟化技术可以提高资源利用率和灵活性，同时也可以提高系统的安全性。
安全隔离：操作系统中的安全隔离可以防止恶意代码和攻击者对系统造成破坏。安全隔离的方法包括访问控制、沙箱技术、安全模式等，它们可以限制应用程序的权限，防止应用程序对系统造成破坏。
通过隔离性，操作系统可以将不同的计算机资源隔离开来，从而保证系统的稳定性和安全性。隔离性也是操作系统实现虚拟化、容器化等技术的重要基础。
4、共享（Sharing）
在操作系统中，共享（Sharing）是指多个进程或用户同时访问同一个资源的能力。
操作系统中的共享可以分为以下几种类型：
文件共享：多个进程可以同时访问同一个文件，这种共享方式称为文件共享。文件共享可以使不同进程之间共同操作同一个文件，从而避免了数据复制和冗余。
内存共享：多个进程可以同时访问同一个内存区域，这种共享方式称为内存共享。内存共享可以使不同进程之间共享数据，从而提高数据共享效率。
网络共享：多个用户可以同时访问同一个网络资源，如共享打印机、共享文件等。网络共享可以使不同用户之间共同使用同一个网络资源，从而提高资源的利用效率。
设备共享：多个进程或用户可以同时访问同一个设备资源，如共享打印机、共享硬盘等。设备共享可以使不同进程或用户之间共同使用同一个设备资源，从而提高设备的利用效率。
通过共享，操作系统可以提高系统资源的利用率，减少资源浪费，同时也可以提高系统的灵活性和可扩展性。共享也是操作系统实现分布式计算、云计算等技术的重要基础。
5、安全性（Security）/权限系统（Permission System）/访问控制系统（Access Control System）
在很多场景下，用户并不想要共享，比如你登录到了一个公共的计算机，例如Athena，你不会想要其他人来读取你的文件。所以在共享的同时，我们也希望在没有必要的时候不共享。这里我们称为Security或者Permission System或者是Access Control System。它们可以保护系统和数据免受未授权访问或者恶意攻击的。
6、Performance
性能（Performance）是操作系统中一个非常重要的指标，它通常用来衡量系统的处理速度和效率。在操作系统中，性能包括多个方面，如响应时间、吞吐量、并发性等。
响应时间是指用户在请求系统资源后，系统响应的时间。响应时间越短，用户就越容易接受系统的性能。在操作系统中，响应时间通常是通过优化系统的调度算法、缓存管理和内存管理等方面来实现的。
吞吐量是指系统在单位时间内处理的任务量。吞吐量越大，系统的处理效率就越高。在操作系统中，吞吐量通常是通过优化系统的调度算法、I/O管理和并发性等方面来实现的。
并发性是指系统在同一时间能够处理的任务数。在操作系统中，通过优化系统的进程管理、线程管理和内存管理等方面，可以提高系统的并发性，从而提高系统的性能。
除了上述几个方面，操作系统中还有许多其他方面的性能指标，如CPU利用率、内存利用率、磁盘I/O速度等等。这些性能指标都是衡量操作系统性能的重要指标，对于优化系统性能具有重要意义。
总之，性能是操作系统中非常重要的一个指标，它涉及到系统的处理速度、效率和用户体验等方面。优化系统性能是操作系统设计和开发的一个重要目标，也是保证系统高效运行的关键手段。操作系统需要至少不阻止应用程序获得高性能，甚至需要帮助应用程序获得高性能。
7、可扩展性
现代操作系统必须支持大量不同类型的应用程序和用户场景，这需要操作系统提供灵活的设计和扩展性，以满足不同类型的用户需求。
例如，一个操作系统需要支持文本编辑器、游戏、数据库服务器、云计算等不同类型的应用程序，并为每种类型的应用程序提供合适的资源管理和调度策略。这需要操作系统提供灵活的调度算法和资源管理机制，以确保所有类型的应用程序都能在系统中得到适当的资源和支持。
此外，操作系统还需要支持不同的用户场景，例如桌面用户、服务器用户、嵌入式系统用户等。这需要操作系统提供不同的配置选项和安装程序，以便用户可以选择适合自己需求的操作系统版本和配置。
总之，现代操作系统必须具备灵活的设计和扩展性，以支持不同类型的应用程序和用户场景。这需要操作系统提供灵活的调度算法、资源管理和配置选项，以确保所有类型的应用程序和用户需求都能得到满足。

添加图片注释，不超过 140 字（可选）
1.2 操作系统结构
操作系统是一个复杂的软件系统，通常由多个层次结构组成，每个层次完成不同的任务和功能。下面是操作系统常见的结构层次：
1.2.1 应用程序层：
应用程序层处于最高层，应用程序直接运行在这一层，例如文本编辑器、游戏、数据库等。应用程序可以使用操作系统提供的API（应用程序接口）来访问底层硬件和系统服务。
应用程序运行在操作系统的最上层，它们通常被称为用户空间（Userspace）程序，这些程序是用户直接操作和使用的。这些应用程序可能是文本编辑器、编译器、浏览器、图形界面应用程序等等，它们运行在操作系统提供的抽象层之上，通过系统调用等方式来与操作系统进行交互和协作。
1.2.2 用户空间
用户空间处于应用程序层下面的一层，它包含一些用户空间的库和工具，例如C库、shell等，它们提供了一些基本的系统服务和工具，例如文件管理、进程管理、网络通信等。
应用程序与Kernel进行交互时，需要通过系统调用来进行，这些系统调用提供了一些标准化的接口，例如文件读写、进程管理、网络通信等，应用程序可以调用这些系统调用来获取操作系统提供的服务和资源。因此，应用程序与Kernel之间形成了一个明显的分离，应用程序无法直接访问底层硬件资源和Kernel中的数据结构，只能通过操作系统提供的接口和服务来进行交互和协作。
1.2.3 内核空间
这是操作系统的核心部分，也称为内核（Kernel），它包含了操作系统最基本的服务和功能，例如进程管理、内存管理、文件系统、网络协议等。内核空间运行在CPU特权模式下，可以直接访问硬件资源。
Kernel可以被视为操作系统的核心或者中心部分，它是计算机资源的守护者。当计算机启动时，Kernel是最先被加载和执行的程序，它负责管理系统资源、进程和内存，以及控制和调度进程的执行。Kernel还负责和硬件资源进行交互，包括磁盘、网络、输入输出设备等，通过驱动程序来控制这些硬件资源的访问和使用。同时，Kernel还提供了一些系统服务，例如文件系统、网络协议栈等，这些服务被用户空间的程序调用来进行文件读写、网络通信等操作。因此，Kernel是操作系统的一个非常重要的组成部分，它提供了操作系统的核心功能和服务。在Kernel内部，通常会包含以下几个核心部分：
① 进程管理（Process Management）：Kernel负责管理所有运行在计算机上的进程，包括进程的创建、销毁、调度等。
② 内存管理（Memory Management）：Kernel负责管理计算机的物理内存，包括内存的分配、释放、虚拟内存管理等。
③ 文件系统（File System）：Kernel负责管理磁盘上的文件和目录，包括文件的创建、读写、删除等。
文件系统是管理计算机文件的重要组成部分。它不仅负责文件的存储和访问，还管理文件的命名和组织方式。文件系统通常通过在磁盘上划分逻辑分区来管理文件，每个分区可以有自己的文件系统类型和格式。
文件系统中的文件名和目录名组成了一个层级结构的命名空间，使得用户可以轻松地查找和组织文件。这个层级结构通常被称为目录树或文件树，它的根目录通常是一个特殊的目录，例如在Linux系统中是“/”，在Windows系统中是“C:\”。
文件系统还可以提供许多其他的功能，例如访问控制、文件共享、快照和备份等。它们通常会定义一些系统调用，允许用户程序访问和操作文件系统中的文件和目录。
④ 网络管理（Network Management）：Kernel负责管理计算机的网络连接和数据传输，包括网络协议栈的实现、网络接口的管理等。
在一个真实的完备的操作系统中，会有很多很多其他的服务，比如在不同进程之间通信的进程间通信服务，比如一些与网络关联的软件（TCP/IP协议栈），比如支持声卡的软件，比如支持数百种不同磁盘，不同网卡的驱动。以及图形界面、声音和视频播放、安全性和加密服务、虚拟化和容器化支持等等。因此，一个完备的操作系统，其内核通常会是一个庞大的软件系统，包含大量的内容，由多个模块组成，每个模块都专门处理不同的任务。这些模块通常会紧密地相互协作，以实现系统的各种功能。例如，驱动程序模块可能会与文件系统模块协作，以将磁盘上的数据读入内存中，然后通过网络服务模块将数据发送到远程计算机上。
⑤ 内核安全问题
关于内核还有一些安全的考虑，我们可以称之为Access Control。Access Control是操作系统中非常重要的一部分，可以帮助保护系统的安全性和完整性，防止不经授权的访问或恶意攻击。Access Control可以分为多个层面，例如基于用户身份的访问控制、基于进程或程序的访问控制、基于文件或资源的访问控制等等。在操作系统中，通常会使用访问控制列表（Access Control List，ACL）或访问控制矩阵（Access Control Matrix，ACM）等方法来实现Access Control。
需要知道的是，在Kernel内部，通常会使用一些常见的软件架构来组织代码和数据，以便于实现和维护。例如，常见的软件架构包括：
分层架构（Layered Architecture）：将系统分为不同的层次，每个层次负责不同的任务，层与层之间通过定义好的接口进行交互。
微内核架构（Microkernel Architecture）：将系统内核最小化，只保留最基本的服务和接口，其他服务和功能则通过插件等方式实现，以提高系统的灵活性和可扩展性。
单体内核架构（Monolithic Kernel Architecture）：将所有服务和功能都集成在一个内核中，以提高系统的性能和稳定性。
不同的操作系统采用不同的内核架构，例如Linux内核采用的是单体内核架构，而微软的Windows NT则采用了分层架构。
1.2.4 硬件层
这是操作系统下面的最底层，包含了物理硬件，例如CPU、内存、硬盘、网络接口等。操作系统通过驱动程序来访问硬件资源，驱动程序是一个特殊的软件模块，可以直接与硬件通信。这些驱动程序被称为设备驱动程序，可以控制和管理硬件资源。操作系统的其他层级，例如内核、用户空间和应用程序层，都是基于这些硬件资源构建的，通过操作系统来管理和协调硬件资源的使用。
总之，操作系统结构层次分明，每个层次都完成不同的任务和功能，各层之间通过API和调用接口进行交互。这种结构能够实现操作系统的模块化设计和实现，从而提高操作系统的可维护性和可扩展性。
如下图，我们用一个矩形表示一个计算机，这个计算机有一些硬件资源，我会将它放在矩形的下面，硬件资源包括了CPU，内存，磁盘，网卡。所以硬件资源在最低一层。
在这个架构的最上层，我们会运行各种各样的应用程序，如：文本编辑器（VI）、C编译器（CC）、Shell，所以这些就是正在运行的所有程序。这里程序都运行在同一个空间中，这个空间通常会被称为用户空间（Userspace）。
区别于用户空间程序，有一个特殊的程序总是会在运行，它称为Kernel。Kernel是计算机资源的守护者。当你打开计算机时，Kernel总是第一个被启动。Kernel程序只有一个，它维护数据来管理每一个用户空间进程。

添加图片注释，不超过 140 字（可选）
从上面我们可以对系统调用与内核空间和用户空间有了一些了解，我们对此总结如下：
系统调用是应用程序请求内核服务的机制,它允许应用程序访问操作系统资源如文件、网络等。
在代码中,系统调用和普通函数调用看起来相同。例如open()、read()、write()等函数,它们实际上都会触发相应的系统调用。
当应用程序执行系统调用时,会切换到内核模式。内核会检查参数,执行对应的系统服务,然后返回控制权与结果给应用程序。
每个操作系统都有一套内置的系统调用接口,例如Unix/Linux系统中常见的read、write、open等。这套接口决定了应用程序能访问什么资源。
使用系统调用比直接访问硬件资源更安全,因为它需要通过内核进行权限检查和参数校验。
1.3 系统调用示例
下面是一个简单的C语言代码示例,展示了open等系统调用的使用:
#include <sys/types.h> 
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
  // 1. 调用open系统调用打开文件
  int fd = open("test.txt", O_RDONLY);  

  if(fd == -1) {
    perror("open");
    return 1;
  }
  // 2. 调用read系统调用读取文件内容
  char buf[100];
  ssize_t nread = read(fd, buf, sizeof(buf));
  if(nread == -1) {
    perror("read"); 
    return 1;
  }
  // 3. 输出读取到的内容
  buf[nread] = '\0';
  printf("Read %zd bytes: %s\n", nread, buf);
  // 4. 调用close系统调用关闭文件 
  close(fd);
  return 0;
}
这个程序的主要步骤是:
调用open系统调用打开文件
调用read系统调用读取文件
调用close系统调用关闭文件
其中，open作为一个系统调用,在应用程序调用open时会发生上下文切换,程序进入内核态。
内核根据open的参数(文件名,打开模式等)来定位并打开具体文件,这可能包括与磁盘的交互来读取文件元数据。
内核会为这个打开的文件分配一个唯一的文件描述符编号,并返回给应用程序。
返回到用户程序后,fd变量就保存着这个文件描述符,它是应用程序用来操作这个打开文件对象的唯一引用。
后续读写这个文件的read/write等函数都需要使用这个fd来表示要操作的文件对象。
本段代码采用了read函数，read同样会触发内核系统调用,内核根据fd定位文件,从内核打开文件对象进行读取,并把数据拷贝到用户空间buf中。
当然你也可以使用write函数进行测试。
文件描述符实际上对应内核一个打开文件表项,记录了文件状态等信息。它代理了应用与文件内核对象的引用。
关于open、read等系统调用，我会单独写一篇文章。
